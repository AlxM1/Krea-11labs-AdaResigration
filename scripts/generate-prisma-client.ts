#!/usr/bin/env tsx
/**
 * Prisma Client Generator Script
 *
 * This script generates the Prisma client types when the Prisma CDN is unavailable.
 * It parses the schema.prisma file and generates TypeScript types.
 */

import * as fs from 'fs';
import * as path from 'path';

const schemaPath = path.join(__dirname, '../prisma/schema.prisma');
const outputDir = path.join(__dirname, '../apps/web/node_modules/.prisma/client');

// Parse schema.prisma
const schemaContent = fs.readFileSync(schemaPath, 'utf-8');

// Extract models
interface Field {
  name: string;
  type: string;
  isOptional: boolean;
  isArray: boolean;
  isRelation: boolean;
  defaultValue?: string;
}

interface Model {
  name: string;
  fields: Field[];
}

interface EnumDef {
  name: string;
  values: string[];
}

function parseSchema(content: string): { models: Model[]; enums: EnumDef[] } {
  const models: Model[] = [];
  const enums: EnumDef[] = [];

  const lines = content.split('\n');
  let currentModel: Model | null = null;
  let currentEnum: EnumDef | null = null;
  let inBlock = false;
  let blockType = '';

  for (const line of lines) {
    const trimmed = line.trim();

    // Model start
    const modelMatch = trimmed.match(/^model\s+(\w+)\s*\{/);
    if (modelMatch) {
      currentModel = { name: modelMatch[1], fields: [] };
      inBlock = true;
      blockType = 'model';
      continue;
    }

    // Enum start
    const enumMatch = trimmed.match(/^enum\s+(\w+)\s*\{/);
    if (enumMatch) {
      currentEnum = { name: enumMatch[1], values: [] };
      inBlock = true;
      blockType = 'enum';
      continue;
    }

    // Block end
    if (trimmed === '}') {
      if (blockType === 'model' && currentModel) {
        models.push(currentModel);
        currentModel = null;
      } else if (blockType === 'enum' && currentEnum) {
        enums.push(currentEnum);
        currentEnum = null;
      }
      inBlock = false;
      blockType = '';
      continue;
    }

    // Parse model fields
    if (blockType === 'model' && currentModel && trimmed && !trimmed.startsWith('@@') && !trimmed.startsWith('//')) {
      const fieldMatch = trimmed.match(/^(\w+)\s+(\w+)(\[\])?\??/);
      if (fieldMatch) {
        const [, name, type, isArray] = fieldMatch;
        const isOptional = trimmed.includes('?') || trimmed.includes('@default');
        const isRelation = trimmed.includes('@relation') ||
          ['Account', 'Session', 'User', 'Generation', 'Video', 'TrainedModel', 'Workflow', 'Project', 'Subscription', 'UsageLog', 'Notification', 'AIModel'].includes(type);

        currentModel.fields.push({
          name,
          type,
          isOptional,
          isArray: !!isArray,
          isRelation
        });
      }
    }

    // Parse enum values
    if (blockType === 'enum' && currentEnum && trimmed && !trimmed.startsWith('//')) {
      const valueMatch = trimmed.match(/^(\w+)/);
      if (valueMatch) {
        currentEnum.values.push(valueMatch[1]);
      }
    }
  }

  return { models, enums };
}

function prismaTypeToTS(type: string, isOptional: boolean, isArray: boolean, enums: EnumDef[]): string {
  const enumNames = enums.map(e => e.name);

  let tsType: string;
  switch (type) {
    case 'String':
      tsType = 'string';
      break;
    case 'Int':
    case 'Float':
      tsType = 'number';
      break;
    case 'BigInt':
      tsType = 'bigint';
      break;
    case 'Boolean':
      tsType = 'boolean';
      break;
    case 'DateTime':
      tsType = 'Date';
      break;
    case 'Json':
      tsType = 'Prisma.JsonValue';
      break;
    default:
      if (enumNames.includes(type)) {
        tsType = `$Enums.${type}`;
      } else {
        tsType = type; // Relation type
      }
  }

  if (isArray) tsType = `${tsType}[]`;
  if (isOptional) tsType = `${tsType} | null`;

  return tsType;
}

function generateClientTypes(models: Model[], enums: EnumDef[]): string {
  const enumTypes = enums.map(e =>
    `export const ${e.name}: {\n${e.values.map(v => `  ${v}: '${v}'`).join(',\n')}\n};\nexport type ${e.name} = (typeof ${e.name})[keyof typeof ${e.name}];`
  ).join('\n\n');

  const modelTypes = models.map(model => {
    const fields = model.fields
      .filter(f => !f.isRelation)
      .map(f => `  ${f.name}: ${prismaTypeToTS(f.type, f.isOptional, f.isArray, enums)};`)
      .join('\n');

    return `export type ${model.name} = {\n${fields}\n}`;
  }).join('\n\n');

  return `
/**
 * Auto-generated Prisma Client Types
 * Generated by scripts/generate-prisma-client.ts
 */

import { PrismaClient as BasePrismaClient, Prisma as BasePrisma } from '@prisma/client/runtime/client';

export namespace $Enums {
${enums.map(e => `  export const ${e.name} = {\n${e.values.map(v => `    ${v}: '${v}' as const`).join(',\n')}\n  };\n  export type ${e.name} = (typeof ${e.name})[keyof typeof ${e.name}];`).join('\n\n')}
}

export import Prisma = BasePrisma;

${modelTypes}

export { BasePrismaClient as PrismaClient };
`;
}

function generateIndexFile(): string {
  return `
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

const { PrismaClient } = require('@prisma/client/runtime/client');

exports.PrismaClient = PrismaClient;
exports.Prisma = require('@prisma/client/runtime/client').Prisma;

// Re-export enums
const $Enums = require('./index.d.ts');
exports.$Enums = $Enums.$Enums || {};
`;
}

// Main execution
console.log('Parsing Prisma schema...');
const { models, enums } = parseSchema(schemaContent);

console.log(`Found ${models.length} models and ${enums.length} enums`);

// Ensure output directory exists
fs.mkdirSync(outputDir, { recursive: true });

// Generate types
console.log('Generating client types...');
const typesContent = generateClientTypes(models, enums);
fs.writeFileSync(path.join(outputDir, 'index.d.ts'), typesContent);

// Generate index.js
const indexContent = generateIndexFile();
fs.writeFileSync(path.join(outputDir, 'index.js'), indexContent);

// Generate package.json
const packageJson = {
  name: '.prisma/client',
  main: 'index.js',
  types: 'index.d.ts'
};
fs.writeFileSync(path.join(outputDir, 'package.json'), JSON.stringify(packageJson, null, 2));

console.log('Prisma client generated successfully!');
console.log(`Output: ${outputDir}`);
